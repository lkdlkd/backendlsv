const moment = require("moment");
const User = require("../../models/User");
const Order = require("../../models/Order");
const Deposit = require("../../models/History");
const dayjs = require('dayjs');
const utc = require('dayjs/plugin/utc');
const timezone = require('dayjs/plugin/timezone');
const isoWeek = require('dayjs/plugin/isoWeek'); // üß† d√πng ƒë·ªÉ tu·∫ßn b·∫Øt ƒë·∫ßu t·ª´ th·ª© 2

dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(isoWeek); // üëà th√™m d√≤ng n√†y

// H√†m l·∫•y th·ªùi gian b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c theo range
// function getRange(range) {
//     const now = moment();
//     let start, end;
//     switch (range) {
//         case "today":
//             start = now.clone().startOf("day");
//             end = now.clone().endOf("day");
//             break;
//         case "yesterday":
//             start = now.clone().subtract(1, "day").startOf("day");
//             end = now.clone().subtract(1, "day").endOf("day");
//             break;
//         case "this_week":
//             start = now.clone().startOf("week");
//             end = now.clone().endOf("week");
//             break;
//         case "last_week":
//             start = now.clone().subtract(1, "week").startOf("week");
//             end = now.clone().subtract(1, "week").endOf("week");
//             break;
//         case "this_month":
//             start = now.clone().startOf("month");
//             end = now.clone().endOf("month");
//             break;
//         case "last_month":
//             start = now.clone().subtract(1, "month").startOf("month");
//             end = now.clone().subtract(1, "month").endOf("month");
//             break;
//         default:
//             start = now.clone().startOf("day");
//             end = now.clone().endOf("day");
//     }
//     return { start: start.toDate(), end: end.toDate() };
// }

// Chu·∫©n ho√° range: today, yesterday, this_week, last_week, this_month, last_month
function getRange(range) {
    const now = dayjs().tz('Asia/Ho_Chi_Minh'); // th·ªùi gian hi·ªán t·∫°i theo gi·ªù VN
    let start, end;

    switch (range) {
        case "today":
            start = now.startOf("day");
            end = now.endOf("day");
            break;
        case "yesterday":
            start = now.subtract(1, "day").startOf("day");
            end = now.subtract(1, "day").endOf("day");
            break;
        case "this_week":
            start = now.startOf("isoWeek"); // tu·∫ßn b·∫Øt ƒë·∫ßu t·ª´ Th·ª© hai
            end = now.endOf("isoWeek");
            break;
        case "last_week":
            const lastWeek = now.subtract(1, "week");
            start = lastWeek.startOf("isoWeek").startOf("day");
            end = lastWeek.endOf("isoWeek").endOf("day");
            break;
        case "this_month":
            start = now.startOf("month");
            end = now.endOf("month");
            break;
        case "last_month":
            start = now.subtract(1, "month").startOf("month");
            end = now.subtract(1, "month").endOf("month");
            break;
        default:
            start = now.startOf("day");
            end = now.endOf("day");
    }

    // Tr·∫£ v·ªÅ UTC ƒë·ªÉ d√πng v·ªõi MongoDB
    return {
        start: start.toDate(), // t·ª± ƒë·ªông chuy·ªÉn v·ªÅ UTC khi convert sang Date
        end: end.toDate()
    };
}

exports.getStatistics = async (req, res) => {
    try {
        const currentUser = req.user;
        if (!currentUser || currentUser.role !== "admin") {
            return res.status(403).json({ error: 'Ch·ªâ admin m·ªõi c√≥ quy·ªÅn s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y' });
        }

        // L·∫•y range t·ª´ query, m·∫∑c ƒë·ªãnh l√† "today"
        const { doanhthuRange = "today", customStart, customEnd } = req.query;
        let doanhthuTime;
        if (customStart && customEnd) {
            // N·∫øu customEnd ch·ªâ l√† ng√†y (kh√¥ng c√≥ gi·ªù), set v·ªÅ cu·ªëi ng√†y ƒë√≥
            let endDate;
            if (/^\d{4}-\d{2}-\d{2}$/.test(customEnd)) {
                // N·∫øu customEnd l√† h√¥m nay, set v·ªÅ gi·ªù hi·ªán t·∫°i
                const todayStr = dayjs().tz('Asia/Ho_Chi_Minh').format('YYYY-MM-DD');
                if (customEnd === todayStr) {
                    endDate = new Date(); // gi·ªù hi·ªán t·∫°i
                } else {
                    // Set v·ªÅ cu·ªëi ng√†y customEnd
                    endDate = dayjs(customEnd).tz('Asia/Ho_Chi_Minh').endOf('day').toDate();
                }
            } else {
                // N·∫øu customEnd c√≥ c·∫£ gi·ªù ph√∫t gi√¢y, d√πng lu√¥n
                endDate = new Date(customEnd);
            }
            doanhthuTime = {
                start: dayjs(customStart).tz('Asia/Ho_Chi_Minh').startOf('day').toDate(),
                end: endDate
            };
        } else {
            doanhthuTime = getRange(doanhthuRange);
        }
        // T·ªïng s·ªë th√†nh vi√™n
        const tonguser = await User.countDocuments();
        // T·ªïng s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng
        const balanceAgg = await User.aggregate([
            { $group: { _id: null, totalBalance: { $sum: "$balance" } } }
        ]);
        const tongtienweb = balanceAgg[0] ? balanceAgg[0].totalBalance : 0;

        // T·ªïng s·ªë ƒë∆°n ƒëang ch·∫°y
        const tongdondangchay = await Order.countDocuments({
            status: { $in: ["running", "In progress", "Processing", "Pending"] }
        });

        // T·ªïng doanh thu (l·ª£i nhu·∫≠n) theo t·ª´ng DomainSmm v√† t·ªïng ti·ªÅn ho√†n theo tr·∫°ng th√°i ƒë∆°n t·∫°i th·ªùi ƒëi·ªÉm ho√†n ti·ªÅn
        const revenueAgg = await Order.aggregate([
            {
                $match: {
                    status: { $in: ["running", "In progress", "Processing", "Pending", "Completed", "Partial" , "Canceled"] },
                    createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end }
                }
            },
            {
                $group: { _id: "$DomainSmm", totalLai: { $sum: "$lai" }, totalTientieu: { $sum: "$tientieu" }, totalCost: { $sum: "$totalCost" } }
            }
        ]);

        // T√≠nh t·ªïng ti·ªÅn ho√†n cho t·ª´ng DomainSmm d·ª±a tr√™n tr·∫°ng th√°i ƒë∆°n t·∫°i th·ªùi ƒëi·ªÉm ho√†n ti·ªÅn
        // L·∫•y t·∫•t c·∫£ l·ªãch s·ª≠ ho√†n ti·ªÅn trong range
        const refundsForDomain = await Deposit.aggregate([
            { $match: { hanhdong: { $regex: "Ho√†n ti·ªÅn", $options: "i" }, createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end } } },
            { $project: { madon: 1, tongtien: 1 } }
        ]);
        // Join v·ªõi Order ƒë·ªÉ l·∫•y domain v√† tr·∫°ng th√°i t·∫°i th·ªùi ƒëi·ªÉm ho√†n ti·ªÅn
        const madonListForDomain = refundsForDomain.map(r => r.madon);
        const orderListForDomain = await Order.find({ Madon: { $in: madonListForDomain } }, { Madon: 1, DomainSmm: 1, status: 1 });
        // Map madon -> domain, status
        const madonDomainMap = {};
        orderListForDomain.forEach(o => {
            madonDomainMap[o.Madon] = { domain: o.DomainSmm, status: o.status };
        });
        // Gom t·ªïng ti·ªÅn ho√†n theo domain v√† tr·∫°ng th√°i
        const refundDomainMap = {};
        refundsForDomain.forEach(r => {
            const info = madonDomainMap[r.madon];
            if (!info) return;
            const domain = info.domain || 'Unknown';
            const status = info.status;
            if (!refundDomainMap[domain]) {
                refundDomainMap[domain] = { totalRefund: 0, totalRefundPartial: 0, totalRefundCanceled: 0 };
            }
            refundDomainMap[domain].totalRefund += r.tongtien;
            if (status === 'Partial') refundDomainMap[domain].totalRefundPartial += r.tongtien;
            if (status === 'Canceled') refundDomainMap[domain].totalRefundCanceled += r.tongtien;
        });
        // G·∫Øn t·ªïng ti·ªÅn ho√†n v√†o t·ª´ng domain
        revenueAgg.forEach(item => {
            const refund = refundDomainMap[item._id] || {};
            item.totalRefund = refund.totalRefund || 0;
            item.totalRefundPartial = refund.totalRefundPartial || 0;
            item.totalRefundCanceled = refund.totalRefundCanceled || 0;
        });
        // T·ªïng l·ª£i nhu·∫≠n t·∫•t c·∫£ DomainSmm trong range
        const tongdoanhthu = revenueAgg.reduce((sum, item) => sum + (item.totalLai || 0), 0);

        // Doanh thu theo range
        const revenueRangeAgg = await Order.aggregate([
            {
                $match: {
                    createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end },
                    status: { $in: ["running", "In progress", "Processing", "Pending", "Completed", "Partial", "Canceled"] }
                }
            },
            {
                $group: { _id: null, total: { $sum: "$totalCost" } }
            }
        ]);
        const tongdoanhthuhnay = revenueRangeAgg[0] ? revenueRangeAgg[0].total : 0;

        // T·ªïng s·ªë n·∫°p theo range
        const depositRangeAgg = await Deposit.aggregate([
            {
                $match: {
                    createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end },
                    hanhdong: { $regex: "(n·∫°p ti·ªÅn|C·ªông ti·ªÅn)", $options: "i" }
                }
            },
            {
                $group: {
                    _id: null,
                    total: { $sum: "$tongtien" }
                }
            }
        ]);
        const tongnapngay = depositRangeAgg[0] ? depositRangeAgg[0].total : 0;

        // T·ªïng s·ªë n·∫°p trong th√°ng
        const startMonth = moment().startOf("month").toDate();
        const depositMonthAgg = await Deposit.aggregate([
            {
                $match: {
                    createdAt: { $gte: startMonth },
                    hanhdong: { $regex: "(n·∫°p ti·ªÅn|C·ªông ti·ªÅn)", $options: "i" }
                }
            },
            { $group: { _id: null, totalDepositMonth: { $sum: "$tongtien" } } }
        ]);
        const tongnapthang = depositMonthAgg[0] ? depositMonthAgg[0].totalDepositMonth : 0;

        // T·ªïng ƒë√£ n·∫°p: L·∫•y t·ªïng t·ª´ tr∆∞·ªùng tongnap c·ªßa User
        const userDepositAgg = await User.aggregate([
            { $group: { _id: null, totalDeposited: { $sum: "$tongnap" } } }
        ]);
        const tongdanap = userDepositAgg[0] ? userDepositAgg[0].totalDeposited : 0;


        // Th·ªëng k√™ theo Magoi: s·ªë ƒë∆°n t·∫°o, s·ªë ƒë∆°n Partial, s·ªë ƒë∆°n Canceled, t·ªïng ti·ªÅn, k√®m namesv t·ª´ order ƒë·∫ßu ti√™n
        const magoiStats = await Order.aggregate([
            {
                $match: {
                    createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end }
                }
            },
            {
                $sort: { createdAt: 1 } // ƒë·∫£m b·∫£o l·∫•y order ƒë·∫ßu ti√™n theo th·ªùi gian
            },
            {
                $group: {
                    _id: "$Magoi",
                    totalOrders: { $sum: 1 },
                    partialCount: {
                        $sum: { $cond: [{ $eq: ["$status", "Partial"] }, 1, 0] }
                    },
                    canceledCount: {
                        $sum: { $cond: [{ $eq: ["$status", "Canceled"] }, 1, 0] }
                    },
                    namesv: { $first: "$namesv" },
                    totalAmount: { $sum: "$totalCost" }
                }
            },
            { $project: { Magoi: "$_id", totalOrders: 1, partialCount: 1, canceledCount: 1, namesv: 1, totalAmount: 1, _id: 0 } }
        ]);

        // Bi·ªÉu ƒë·ªì: t·ªïng h·ª£p theo ng√†y trong range
        const chartMatch = { createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end } };
        // ƒê·∫øm s·ªë ƒë∆°n t·∫°o v√† t·ªïng ti·ªÅn m·ªói ng√†y
        const dailyOrders = await Order.aggregate([
            { $match: chartMatch },
            { $group: { 
                _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt", timezone: "Asia/Ho_Chi_Minh" } },
                count: { $sum: 1 },
                total: { $sum: "$totalCost" }
            } },
            { $sort: { _id: 1 } }
        ]);
        // L·∫•y dailyPartial v√† dailyCanceled t·ª´ b·∫£ng HistoryUser, join v·ªõi Order ƒë·ªÉ x√°c ƒë·ªãnh tr·∫°ng th√°i
        const HistoryUser = require("../../models/History");
        // L·∫•y t·∫•t c·∫£ history ho√†n ti·ªÅn trong range
        const allRefunds = await HistoryUser.aggregate([
            { $match: { hanhdong: { $regex: "Ho√†n ti·ªÅn", $options: "i" }, createdAt: { $gte: doanhthuTime.start, $lte: doanhthuTime.end } } },
            { $project: { madon: 1, tongtien: 1, createdAt: 1 } }
        ]);
        // L·∫•y tr·∫°ng th√°i c√°c m√£ ƒë∆°n li√™n quan
        const madonList = allRefunds.map(r => r.madon);
        // T√¨m theo c·∫£ madon v√† Magoi (nhi·ªÅu h·ªá th·ªëng l∆∞u m√£ ƒë∆°n ·ªü 2 tr∆∞·ªùng kh√°c nhau)
        const orderStatusList = await Order.find({ $or: [ { Madon: { $in: madonList } } ] }, { Madon: 1, status: 1 });
        const madonStatusMap = {};
        orderStatusList.forEach(o => {
            if (o.Madon) madonStatusMap[o.Madon] = o.status;
            if (o.Magoi) madonStatusMap[o.Magoi] = o.status;
        });
        // Gom nh√≥m theo ng√†y v√† tr·∫°ng th√°i
        const partialMap = {};
        const canceledMap = {};
        allRefunds.forEach(r => {
            const status = madonStatusMap[r.madon];
            const date = dayjs(r.createdAt).tz('Asia/Ho_Chi_Minh').format('YYYY-MM-DD');
            if (status === 'Partial') {
                if (!partialMap[date]) partialMap[date] = { _id: date, count: 0, total: 0 };
                partialMap[date].count += 1;
                partialMap[date].total += r.tongtien;
            } else if (status === 'Canceled') {
                if (!canceledMap[date]) canceledMap[date] = { _id: date, count: 0, total: 0 };
                canceledMap[date].count += 1;
                canceledMap[date].total += r.tongtien;
            }
        });
        // Chuy·ªÉn sang m·∫£ng v√† sort
        const dailyPartial = Object.values(partialMap).sort((a, b) => a._id.localeCompare(b._id));
        const dailyCanceled = Object.values(canceledMap).sort((a, b) => a._id.localeCompare(b._id));

        // T·ªïng h·ª£p s·ªë ƒë∆°n v√† t·ªïng ti·ªÅn ho√†n Partial/Canceled theo range
        let partialCount = 0, canceledCount = 0, partialHoan = 0, canceledHoan = 0;
        Object.values(partialMap).forEach(item => {
            partialCount += item.count;
            partialHoan += item.total;
        });
        Object.values(canceledMap).forEach(item => {
            canceledCount += item.count;
            canceledHoan += item.total;
        });
        // T·ªïng s·ªë ti·ªÅn n·∫°p m·ªói ng√†y
        const dailyDeposits = await Deposit.aggregate([
            { $match: { ...chartMatch, hanhdong: { $regex: "(n·∫°p ti·ªÅn|C·ªông ti·ªÅn)", $options: "i" } } },
            { $group: { _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt", timezone: "Asia/Ho_Chi_Minh" } }, total: { $sum: "$tongtien" } } },
            { $sort: { _id: 1 } }
        ]);

        // G·ªôp d·ªØ li·ªáu chart th√†nh 1 m·∫£ng dailyChart
        // T·∫°o map theo ng√†y cho t·ª´ng lo·∫°i
        const mapOrders = Object.fromEntries(dailyOrders.map(i => [i._id, i]));
        const mapDeposits = Object.fromEntries(dailyDeposits.map(i => [i._id, i]));
        const mapPartial = Object.fromEntries(dailyPartial.map(i => [i._id, i]));
        const mapCanceled = Object.fromEntries(dailyCanceled.map(i => [i._id, i]));

        // L·∫•y t·∫•t c·∫£ ng√†y xu·∫•t hi·ªán ·ªü b·∫•t k·ª≥ lo·∫°i n√†o
        const allDates = Array.from(new Set([
            ...dailyOrders.map(i => i._id),
            ...dailyDeposits.map(i => i._id),
            ...dailyPartial.map(i => i._id),
            ...dailyCanceled.map(i => i._id)
        ])).sort();

        const dailyChart = allDates.map(date => ({
            date,
            orders: mapOrders[date]?.count || 0,
            ordersTotal: mapOrders[date]?.total || 0,
            deposits: mapDeposits[date]?.total || 0,
            partial: mapPartial[date]?.count || 0,
            partialTotal: mapPartial[date]?.total || 0,
            canceled: mapCanceled[date]?.count || 0,
            canceledTotal: mapCanceled[date]?.total || 0
        }));

        res.status(200).json({
            tonguser,
            tongtienweb,
            tongdondangchay,
            tongdanap,
            tongdoanhthu,
            laiTheoDomain: revenueAgg, // <-- th√™m d√≤ng n√†y
            tongnapthang,
            tongnapngay,
            tongdoanhthuhnay,
            doanhthuRange,
            partialCount, // s·ªë ƒë∆°n Partial theo range
            canceledCount, // s·ªë ƒë∆°n Canceled theo range
            partialHoan, // t·ªïng ti·ªÅn ho√†n Partial
            canceledHoan, // t·ªïng ti·ªÅn ho√†n Canceled
            magoiStats, // th·ªëng k√™ theo Magoi
            chartData: dailyChart
        });
    } catch (error) {
        console.error("L·ªói th·ªëng k√™:", error);
        res.status(500).json({ message: "L·ªói server", error: error.message });
    }
};
