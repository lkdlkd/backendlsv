const axios = require('axios');
const Service = require('../../models/server');
const Order = require('../../models/Order');
const HistoryUser = require('../../models/History');
const SmmSv = require("../../models/SmmSv");
const SmmApiService = require('../Smm/smmServices'); // ho·∫∑c ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ·ª©ng
const Telegram = require('../../models/Telegram');

// L·∫•y ƒë∆°n h√†ng theo category, user, v√† t·ª´ kh√≥a t√¨m ki·∫øm (ph√¢n trang)
async function getOrders(req, res) {
  const user = req.user;
  const { category, search, status } = req.query;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;

  // X√¢y d·ª±ng ƒëi·ªÅu ki·ªán t√¨m ki·∫øm
  let filter = {};
  if (user.role !== 'admin') {
    filter.username = user.username;
  }
  if (category) {
    filter.category = category;
  }
  if (status) {
    filter.status = status;
  }
  if (search) {
    filter.$or = [
      { Madon: { $regex: search, $options: 'i' } },
      { link: { $regex: search, $options: 'i' } }
    ];
  }

  try {
    let selectFields = '-SvID -orderId -DomainSmm -lai -tientieu'; // C√°c tr∆∞·ªùng kh√¥ng c·∫ßn thi·∫øt cho ng∆∞·ªùi d√πng th∆∞·ªùng
    if (user.role === 'admin') {
      selectFields = ''; // admin xem t·∫•t c·∫£ c√°c tr∆∞·ªùng
    }

    const orders = await Order.find(filter, selectFields)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .populate('username');

    const totalOrders = await Order.countDocuments(filter);

    if (orders.length === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }

    res.status(200).json({
      orders,
      currentPage: page,
      totalPages: Math.ceil(totalOrders / limit),
      totalOrders
    });
  } catch (error) {
    res.status(500).json({
      message: 'C√≥ l·ªói x·∫£y ra khi l·∫•y ƒë∆°n h√†ng',
      error: error.message
    });
  }
}
// H√†m x√≥a ƒë∆°n h√†ng (ch·ªâ admin)
async function deleteOrder(req, res) {
  const user = req.user;
  if (!user || user.role !== "admin") {
    return res.status(403).json({ error: 'Ch·ªâ admin m·ªõi c√≥ quy·ªÅn s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y' });
  }

  const { orderId } = req.params;
  try {
    const order = await Order.findOneAndDelete({ _id: orderId });
    if (!order) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }
    res.status(200).json({ message: 'X√≥a ƒë∆°n h√†ng th√†nh c√¥ng', order });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'C√≥ l·ªói x·∫£y ra khi x√≥a ƒë∆°n h√†ng', error: error.message });
  }
}
// order
async function fetchServiceData(magoi) {
  const serviceFromDb = await Service.findOne({ Magoi: magoi });
  if (!serviceFromDb) throw new Error('D·ªãch v·ª• kh√¥ng t·ªìn t·∫°i');
  return serviceFromDb;
}

async function fetchSmmConfig(domain) {
  const smmSvConfig = await SmmSv.findOne({ name: domain });
  if (!smmSvConfig || !smmSvConfig.url_api || !smmSvConfig.api_token) {
    throw new Error('L·ªói khi mua d·ªãch v·ª•, vui l√≤ng ib admin');
  }
  return smmSvConfig;
}

async function sendTelegramNotification(data) {
  const { telegramBotToken, telegramChatId, message } = data;
  if (telegramBotToken && telegramChatId) {
    try {
      await axios.post(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
        chat_id: telegramChatId,
        text: message,
      });
      console.log('Th√¥ng b√°o Telegram ƒë√£ ƒë∆∞·ª£c g·ª≠i.');
    } catch (error) {
      console.error('L·ªói g·ª≠i th√¥ng b√°o Telegram:', error.message);
    }
  } else {
    console.log('Thi·∫øu th√¥ng tin c·∫•u h√¨nh Telegram.');
  }
}

async function addOrder(req, res) {
  try {
    // L·∫•y user t·ª´ middleware
    const user = req.user;
    const username = user.username;

    // L·∫•y th√¥ng tin t·ª´ body
    const { link, category, quantity, magoi, note, comments, ObjectLink } = req.body;
    const qty = Number(quantity);
    const formattedComments = comments ? comments.replace(/\r?\n/g, "\r\n") : "";

    // L·∫•y th√¥ng tin d·ªãch v·ª•
    const serviceFromDb = await fetchServiceData(magoi);
    const smmSvConfig = await fetchSmmConfig(serviceFromDb.DomainSmm);

    const smm = new SmmApiService(smmSvConfig.url_api, smmSvConfig.api_token);
    const allServices = await smm.services();
    const serviceFromApi = allServices.find(
      s => s.service === Number(serviceFromDb.serviceId) || s.service === serviceFromDb.serviceId
    );

    if (!serviceFromApi) throw new Error('D·ªãch v·ª• kh√¥ng t·ªìn t·∫°i');
    // Ki·ªÉm tra s·ªë d∆∞ v√† s·ªë l∆∞·ª£ng
    const totalCost = serviceFromDb.rate * qty;
    const apiRate = serviceFromApi.rate * smmSvConfig.tigia;
    if (apiRate > serviceFromDb.rate) {
      throw new Error('L·ªói khi mua d·ªãch v·ª•, vui l√≤ng ib admin');
    }
    if (qty < serviceFromDb.min || qty > serviceFromDb.max) {
      throw new Error('S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá');
    }
    if (user.balance < totalCost) {
      throw new Error('S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch');
    }
    if (serviceFromDb.isActive === false) {
      throw new Error('D·ªãch v·ª• b·∫£o tr√¨, vui l√≤ng li√™n h·ªá admin');
    }
    const lai = totalCost - (apiRate * qty);
    const tientieu = apiRate * qty;
    // G·ª≠i y√™u c·∫ßu mua d·ªãch v·ª•
    const purchasePayload = {
      link,
      quantity: qty,
      service: serviceFromDb.serviceId,
      comments: formattedComments,
    };
    const purchaseResponse = await smm.order(purchasePayload);
    if (!purchaseResponse || !purchaseResponse.order) {
      throw new Error('L·ªói khi mua d·ªãch v·ª•, vui l√≤ng ib admin');
    }
    // C·∫≠p nh·∫≠t s·ªë d∆∞ v√† l∆∞u ƒë∆°n h√†ng
    const newBalance = user.balance - totalCost;
    user.balance = newBalance;
    await user.save();

    const lastOrder = await Order.findOne({}).sort({ Madon: -1 });
    const newMadon = lastOrder && lastOrder.Madon ? Number(lastOrder.Madon) + 1 : 10000;

    const createdAt = new Date();
    const orderData = new Order({
      Madon: newMadon,
      Magoi: serviceFromDb.Magoi,
      username,
      SvID: serviceFromDb.serviceId,
      orderId: purchaseResponse.order,
      namesv: `${serviceFromDb.maychu} ${serviceFromDb.name}`,
      category,
      link,
      start: 0,
      quantity: qty,
      rate: serviceFromDb.rate,
      totalCost,
      status: 'Pending',
      note,
      ObjectLink,
      comments: formattedComments,
      DomainSmm: serviceFromDb.DomainSmm,
      tientieu: tientieu,
      lai: lai,
      refil: serviceFromDb.refil,
      cancel: serviceFromDb.cancel,
    });

    const HistoryData = new HistoryUser({
      username,
      madon: newMadon,
      hanhdong: 'T·∫°o ƒë∆°n h√†ng',
      link,
      tienhientai: user.balance + totalCost,
      tongtien: totalCost,
      tienconlai: newBalance,
      createdAt,
      mota: `TƒÉng ${serviceFromDb.maychu} ${serviceFromDb.name} th√†nh c√¥ng cho uid ${link}`,
    });

    await orderData.save();
    await HistoryData.save();

    // G·ª≠i th√¥ng b√°o Telegram n·∫øu c√≥ c·∫•u h√¨nh
    const teleConfig = await Telegram.findOne();
    if (teleConfig && teleConfig.botToken && teleConfig.chatId) {
      // Gi·ªù Vi·ªát Nam (UTC+7)
      const createdAtVN = new Date(createdAt.getTime() + 7 * 60 * 60 * 1000);
      const telegramMessage = `üìå *ƒê∆°n h√†ng m·ªõi ƒë√£ ƒë∆∞·ª£c t·∫°o!*\n` +
        `üë§ *Kh√°ch h√†ng:* ${username}\n` +
        `üÜî *M√£ ƒë∆°n:* ${newMadon}\n` +
        `üîπ *D·ªãch v·ª•:* ${serviceFromDb.maychu} ${serviceFromDb.name}\n` +
        `üîó *Link:* ${link}\n` +
        `üî∏ *Rate:* ${serviceFromDb.rate}\n` +
        `üìå *S·ªë l∆∞·ª£ng:* ${qty}\n` +
        `üí∞ *Ti·ªÅn c≈©:* ${Number(Math.floor(Number(user.balance + totalCost))).toLocaleString("en-US")} VNƒê\n` +
        `üí∞ *T·ªïng ti·ªÅn:* ${Number(Math.floor(Number(totalCost))).toLocaleString("en-US")} VNƒê\n` +
        `üí∞ *TI·ªÅn c√≤n l·∫°i:* ${Number(Math.floor(Number(newBalance))).toLocaleString("en-US")} VNƒê\n` +
        `üìÜ *Ng√†y t·∫°o:* ${createdAtVN.toLocaleString("vi-VN", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        })}\n` +
        `üìù *Ghi ch√∫:* ${note || 'Kh√¥ng c√≥'}\n` +
        `Ngu·ªìn: ${serviceFromDb.DomainSmm}`;
      await sendTelegramNotification({
        telegramBotToken: teleConfig.botToken,
        telegramChatId: teleConfig.chatId,
        message: telegramMessage,
      });
    }

    res.status(200).json({ message: 'Mua d·ªãch v·ª• th√†nh c√¥ng' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: error.message });
  }
}
// H√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng (ch·ªâ admin)
async function updateOrderStatus(req, res) {
  try {
    const user = req.user;
    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Ch·ªâ admin m·ªõi c√≥ quy·ªÅn c·∫≠p nh·∫≠t ƒë∆°n h√†ng' });
    }
    const { Madon } = req.params;
    const { start, dachay, status, iscancel } = req.body;
    const order = await Order.findOne({ Madon });
    if (!order) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }
    if (start !== undefined) order.start = start;
    if (dachay !== undefined) order.dachay = dachay;
    if (status !== undefined) order.status = status;
    if (iscancel !== undefined) order.iscancel = iscancel;
    await order.save();
    return res.status(200).json({ success: true, order });
  } catch (error) {
    return res.status(500).json({ error: error.message });
  }
}


module.exports = {
  addOrder,
  deleteOrder,
  getOrders,
  updateOrderStatus,
};
